# ADR-0003: UUID4 for Task Identifiers

> **Scope**: Task identifier generation strategy affecting domain model, storage keys, API design, and Phase II database schema.

- **Status:** Accepted
- **Date:** 2026-01-03
- **Feature:** 001-task-crud-operations
- **Context:** Task entities require globally unique identifiers for creation, retrieval, updates, and deletion. Phase I uses in-memory dictionary storage with string keys. Phase II will migrate to PostgreSQL database. Need identifier strategy that works across both phases, supports distributed systems (Phase III AI agents), and prevents ID collisions without coordination.

<!-- Significance checklist (ALL must be true to justify this ADR)
     1) Impact: Long-term ✅ - Affects Phase II database schema, Phase III offline creation, future distributed architecture
     2) Alternatives: ✅ - UUID4, auto-increment integers, NanoID, ULID, CUID considered
     3) Scope: Cross-cutting ✅ - Affects domain model, storage layer, API design, database schema, future distributed systems
-->

## Decision

**Task Identifier Strategy:**
- **Format:** UUID4 (Universally Unique Identifier, Version 4)
- **Generation:** Python `uuid.uuid4()` from stdlib
- **Representation:** String format (e.g., `"550e8400-e29b-41d4-a716-446655440000"`)
- **Domain Model:** `Task.id: str` attribute (immutable, set once at creation)
- **Storage Keys:** UUID4 strings as dictionary keys (Phase I) / primary keys (Phase II)
- **User Display:** First 8 characters shown in CLI table view (full UUID in detail view)

**Implementation Details:**
```python
import uuid
from datetime import datetime

class Task:
    def __init__(self, title: str, description: str = ""):
        self.id = str(uuid.uuid4())  # Generate UUID4, convert to string
        self.title = title.strip()
        # ... other attributes
```

**Collision Probability:**
- UUID4 space: 2^122 unique identifiers (340 undecillion)
- Collision probability: Negligible (< 10^-18 for billions of tasks)
- No coordination needed between clients/servers

## Consequences

### Positive

- **Global Uniqueness:** No collisions across distributed systems, clients, or time zones
- **No Coordination:** Tasks created independently without centralized ID server
- **Offline Creation:** Phase III AI agents can create tasks offline, sync later (no ID conflicts)
- **Database Migration:** UUID primary keys in Phase II PostgreSQL (native UUID column type)
- **Merge-Friendly:** Tasks from different sources (users, AI agents, imports) can merge without ID conflicts
- **Security:** IDs are non-sequential, harder to enumerate (mild security benefit)
- **Stdlib Only:** `uuid.uuid4()` is Python stdlib, no external dependencies
- **User-Approved:** Selected during specification creation (user preference)
- **Future-Proof:** Works across all phases (I: console, II: web, III: AI, IV: K8s, V: cloud-native)

### Negative

- **String Length:** 36 characters (32 hex + 4 hyphens) vs. 1-10 characters for integers
- **CLI Display:** Full UUIDs too long for table view (mitigated: show first 8 chars, full ID in detail view)
- **URL Ugliness:** Phase II URLs like `/tasks/550e8400-e29b-41d4-a716-446655440000` (longer than `/tasks/123`)
- **Index Size:** PostgreSQL UUID indexes larger than integer indexes (8-16 bytes vs. 4-8 bytes)
- **No Natural Ordering:** UUIDs are random, cannot sort tasks by creation order using ID (mitigated: explicit `created_at` timestamp)
- **Copy-Paste Errors:** Users may mistype long UUIDs (mitigated: CLI autocomplete for first 8 chars)
- **Memory Overhead:** Minimal but measurable (36-byte strings vs. 4-byte integers) - acceptable per NFR-002 (100MB for 10K tasks)

## Alternatives Considered

### Alternative A: Auto-Increment Integers
- **Approach:** Sequential IDs (1, 2, 3...) generated by database or in-memory counter
- **Pros:** Short (1-10 characters), human-friendly, natural sort order, small index size, simple URLs (`/tasks/42`)
- **Cons:** Requires centralized ID generation (coordination), collision risk in distributed systems, Phase III offline creation impossible, exposes task count (security leak)
- **Rejected Because:** Breaks in distributed systems (Phase III AI agents creating tasks offline). Requires coordination (violates offline-first principle for Phase III). Cannot merge tasks from multiple sources without ID conflicts.

### Alternative B: NanoID
- **Approach:** Short, URL-safe unique IDs (e.g., `"V1StGXR8_Z5jdHi6B"`)
- **Pros:** Shorter than UUID (21 characters default), URL-friendly, cryptographically strong, configurable length
- **Cons:** Requires external library (`nanoid`), violates Phase I stdlib-only constraint, less familiar than UUID, custom implementation needed in PostgreSQL
- **Rejected Because:** Violates Phase I "no external dependencies" constraint (Constitution lines 189-222). UUID4 is stdlib, NanoID is not. Marginal length benefit (21 vs 36 chars) doesn't justify dependency.

### Alternative C: ULID (Universally Unique Lexicographically Sortable Identifier)
- **Approach:** 26-character IDs with timestamp prefix, lexicographically sortable (e.g., `"01ARZ3NDEKTSV4RRFFQ69G5FAV"`)
- **Pros:** Shorter than UUID (26 vs 36 chars), sortable by creation time, monotonic ordering
- **Cons:** Requires external library (`python-ulid`), violates Phase I stdlib-only constraint, not widely supported in PostgreSQL
- **Rejected Because:** Violates Phase I stdlib-only constraint. Sortability benefit marginal (we have explicit `created_at` timestamp for sorting). UUID4 is more widely supported.

### Alternative D: CUID (Collision-Resistant Unique Identifier)
- **Approach:** Client-generated IDs with timestamp, counter, fingerprint (e.g., `"cjld2cjxh0000qzrmn831i7rn"`)
- **Pros:** Collision-resistant, sortable, shorter than UUID (25 chars)
- **Cons:** Requires external library (`cuid`), complex algorithm, less mature than UUID, PostgreSQL support unclear
- **Rejected Because:** Violates stdlib-only constraint. UUID4 is mature, battle-tested, widely supported. CUID adds complexity without clear benefit for this use case.

### Alternative E: Composite Keys (user_id + auto-increment)
- **Approach:** Primary key is tuple `(user_id, task_number)` where task_number increments per user
- **Pros:** Human-friendly numbering within user scope, short IDs per user
- **Cons:** Phase I is single-user (no user_id), complex migration to Phase II, no global uniqueness, merge complexity
- **Rejected Because:** Phase I has no user concept (single-user constraint). Adds complexity for no Phase I benefit. UUID4 simpler and works across all phases.

## References

- Feature Spec: [specs/001-task-crud-operations/spec.md](../../specs/001-task-crud-operations/spec.md) (Key Entities line 193, Domain Model Invariant 6 line 239)
- Implementation Plan: [specs/001-task-crud-operations/plan.md](../../specs/001-task-crud-operations/plan.md) (Section 4: ADR Candidates, lines 389-395)
- Data Model: [specs/001-task-crud-operations/data-model.md](../../specs/001-task-crud-operations/data-model.md) (Design Rationale section, lines 292-297)
- Task Entity Contract: [specs/001-task-crud-operations/contracts/task-entity-contract.md](../../specs/001-task-crud-operations/contracts/task-entity-contract.md) (Entity Signature line 40)
- Related ADRs: ADR-0001 (In-Memory Dictionary Storage) - UUID4 strings as dictionary keys
- Python UUID Docs: [uuid - UUID objects](https://docs.python.org/3/library/uuid.html)
- Phase II Migration: PostgreSQL native UUID column type with `gen_random_uuid()` default
