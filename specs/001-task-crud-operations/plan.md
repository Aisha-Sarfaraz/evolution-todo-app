# Implementation Plan: Task CRUD Operations - Phase I

**Branch**: `001-task-crud-operations` | **Date**: 2026-01-03 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-task-crud-operations/spec.md`

**Note**: This plan generated by `/sp.plan` command following approved architectural design.

## Summary

Phase I Task CRUD Operations implements an in-memory Python console todo application with 5 basic CRUD operations (Create, View, Update, Mark Complete, Delete). The architecture follows Constitutional Principle IV (Clean Separation of Concerns) with three distinct layers: Domain (business logic), CLI (user interface), and Storage (in-memory persistence).

**Phase Isolation**: All Phase I code resides in the `Phase-1/` directory, ensuring clean separation from future phases (Phase II: Web App, Phase III: AI, Phase IV: K8s, Phase V: Cloud-Native).

**Key Architectural Decisions**:
1. Three-layer architecture (domain/cli/storage) with dependency inversion
2. Domain-driven design with Task entity and 10 NON-NEGOTIABLE invariants
3. Menu-driven CLI using Python `input()` for user interaction
4. Dictionary-based in-memory storage with UUID4 keys
5. Exception-based error propagation across layers

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: None (stdlib only: datetime, uuid, logging, typing, abc)
**Storage**: In-memory dictionary (`Dict[str, Task]`) - no persistence
**Testing**: pytest (unit + integration), pytest-cov (coverage reporting)
**Target Platform**: Cross-platform console (Windows, Linux, macOS)
**Project Type**: Single (console application)
**Performance Goals**:
- Operations complete within 100ms for lists < 1000 tasks
- Handle up to 10,000 tasks without exceeding 100MB RAM
- Application starts within 1 second

**Constraints**:
- Phase I: In-memory only (no file/database persistence)
- Single-user (no authentication/authorization)
- Console-only interface (no GUI/web)
- No external dependencies (stdlib only)

**Scale/Scope**:
- 5 CRUD operations (Create, View, Update, Complete, Delete)
- 1 domain entity (Task with 7 attributes)
- 60-70 tests (35-40 unit, 25-30 integration)
- 80% minimum unit test coverage

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**✅ Principle I (SDD - Spec-Driven Development)**
- Status: PASS
- Evidence: Specification approved (spec.md), plan references spec throughout
- Workflow: sp.specify → sp.clarify (completed) → sp.plan (in progress) → sp.tasks → sp.implement

**✅ Principle II (No Manual Coding)**
- Status: PASS
- Evidence: All code will be generated via Claude Code following TDD workflow
- Human role: Specification, review, approval; AI role: Implementation, testing

**✅ Principle III (TDD - Test-Driven Development)**
- Status: PASS
- Evidence: Red-Green-Refactor workflow defined in plan (Section 7.4)
- Test Strategy: 60-70 tests, 80% unit coverage, 70% integration coverage
- Enforcement: Test Strategy Architect agent blocks implementation if tests not written first

**✅ Principle IV (Clean Separation of Concerns)**
- Status: PASS
- Evidence: Three-layer architecture (domain/cli/storage) with dependency inversion
- Domain: Pure business logic (no dependencies)
- Storage: Implements RepositoryInterface from domain
- CLI: Orchestrates domain and storage (depends on both)

**✅ Principle V (Code Modularity & Reusability)**
- Status: PASS
- Evidence: RepositoryInterface enables future database swap (Phase II migration path defined)
- Domain layer reusable across phases (Task entity remains unchanged)
- No operational skills created (Phase I is simple, no complex workflows)

**✅ Principle VI (Security, Isolation & Observability)**
- Status: PASS
- Evidence: Structured JSON logging defined (NFR-009 to NFR-011)
- Error handling: User-friendly messages, no stack traces (NFR-012 to NFR-014)
- Note: Multi-user isolation deferred to Phase II (single-user in Phase I per spec Out of Scope)

**Constitution Violations**: None

**Re-evaluation Post-Design**: TBD after Phase 1 design artifacts complete

## Project Structure

### Documentation (this feature)

```text
specs/001-task-crud-operations/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (if needed)
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output (domain contracts)
│   └── task-entity-contract.md
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (Phase-1/ directory - isolated from future phases)

```text
Phase-1/
├── src/
│   ├── __init__.py
│   ├── domain/                    # Pure business logic (no dependencies)
│   │   ├── __init__.py
│   │   ├── task.py                # Task entity with 10 NON-NEGOTIABLE invariants
│   │   └── exceptions.py          # DomainValidationError, DomainStateError, TaskNotFoundError
│   ├── storage/                   # In-memory persistence
│   │   ├── __init__.py
│   │   ├── repository_interface.py  # Abstract interface (enables future DB swap)
│   │   └── memory_repository.py     # Dictionary-based implementation
│   ├── cli/                       # User interface and orchestration
│   │   ├── __init__.py
│   │   ├── menu.py                # Main menu loop
│   │   └── operations.py          # CRUD operation handlers (5 functions)
│   └── main.py                    # Application entry point with logging
├── tests/
│   ├── __init__.py
│   ├── unit/                      # 35-40 tests
│   │   └── domain/
│   │       ├── test_task_entity.py      (12 tests)
│   │       ├── test_task_lifecycle.py   (15 tests)
│   │       └── test_task_validation.py  (10 tests)
│   └── integration/               # 25-30 tests
│       ├── test_create_workflow.py      (6 tests - P1)
│       ├── test_view_workflow.py        (6 tests - P2)
│       ├── test_update_workflow.py      (8 tests - P3)
│       ├── test_complete_workflow.py    (5 tests - P4)
│       └── test_delete_workflow.py      (5 tests - P5)
├── pyproject.toml                 # Python project config (UV package manager)
├── .env.example                   # Environment variables template
├── .gitignore                     # Git ignore rules
└── README.md                      # Phase I setup and usage instructions
```

**Structure Decision**:

Single project structure within `Phase-1/` directory, chosen because:
1. **Phase Isolation**: Prevents cross-phase dependencies; Phase II will add backend/ and frontend/ at root level
2. **Simplicity**: Console application needs no frontend/backend split
3. **Future Migration**: RepositoryInterface enables clean Phase II migration (MemoryRepository → PostgresRepository swap in main.py)
4. **Constitutional Compliance**: Clean layer separation (domain/cli/storage) enforced via directory structure

## Complexity Tracking

**No Constitution violations detected. This section intentionally left empty.**

All complexity is justified by specification requirements:
- Three-layer architecture: Required by Constitution Principle IV (Separation of Concerns)
- UUID4 IDs: User-approved during specification creation; future-proof for distributed systems (Phase II+)
- Exception-based error handling: Python idiomatic; specification defines 3 exception types explicitly

Simpler alternatives rejected with rationale documented in ADRs (Section 4: ADR Candidates).

---

## Component Boundaries & Responsibilities

### Domain Layer (`Phase-1/src/domain/`)

**Responsibility**: Pure business logic, entity definitions, domain invariants. No dependencies on CLI or Storage.

#### Task Entity (`Phase-1/src/domain/task.py`)
- **Spec Reference**: Domain Model section (spec.md lines 225-254)
- **Attributes**:
  - `id: str` - UUID4 (immutable, set on creation)
  - `title: str` - Required, 1-200 chars, trimmed
  - `description: str` - Optional, 0-2000 chars, auto-truncated
  - `status: Literal["pending", "complete"]` - Enum constraint
  - `created_at: datetime` - ISO 8601, immutable
  - `updated_at: datetime` - ISO 8601, updated on modifications
  - `completed_at: Optional[datetime]` - Set when status → "complete"

- **Methods**:
  - `__init__(title, description)` - Constructor with validation
  - `update_title(new_title)` - Update title with validation
  - `update_description(new_description)` - Update description with truncation
  - `mark_complete()` - Transition pending → complete
  - `to_dict()` - Serialize for storage/display

- **10 NON-NEGOTIABLE Invariants**:
  1. Title Non-Emptiness: `Task.title` must be non-empty after trimming (raises `DomainValidationError`)
  2. Title Length: `Task.title` ≤ 200 chars (raises `DomainValidationError`)
  3. Description Length: `Task.description` ≤ 2000 chars (auto-truncate, log warning)
  4. Status Constraint: `Task.status` ∈ {"pending", "complete"} (enforced by type hint)
  5. State Transition: Only `pending → complete` allowed (raises `DomainStateError` if violated)
  6. ID Uniqueness: Every `Task.id` globally unique via UUID4
  7. Created Timestamp Immutability: `Task.created_at` set once at creation
  8. Updated Timestamp: `Task.updated_at` updated on title/description changes
  9. Completed Timestamp: `Task.completed_at` = None when pending, set when complete
  10. Deletion Integrity: Deletion handled by Storage layer, Task object unchanged

#### Domain Exceptions (`Phase-1/src/domain/exceptions.py`)
- **Spec Reference**: Domain Model section (spec.md lines 249-254)
- `DomainValidationError(Exception)` - Input validation failures
- `DomainStateError(Exception)` - Invalid state transitions
- `TaskNotFoundError(Exception)` - Task ID not found in storage

**Dependencies**: None (pure Python stdlib: datetime, uuid, logging, typing)

---

### Storage Layer (`Phase-1/src/storage/`)

**Responsibility**: In-memory persistence using dictionary, isolated from domain and CLI.

#### Repository Interface (`Phase-1/src/storage/repository_interface.py`)
- **Purpose**: Abstract interface for storage operations (enables future database swap)
- **Spec Reference**: Architecture NFR-015 to NFR-017 (spec.md lines 393-398)
- **Methods**:
  - `add(task: Task) -> None` - Store task with UUID4 as key
  - `get(task_id: str) -> Optional[Task]` - Retrieve task by ID
  - `get_all() -> List[Task]` - Retrieve all tasks sorted by created_at DESC
  - `update(task: Task) -> None` - Update existing task
  - `delete(task_id: str) -> None` - Remove task from storage
  - `exists(task_id: str) -> bool` - Check if task exists

#### In-Memory Repository (`Phase-1/src/storage/memory_repository.py`)
- **Storage Structure**: `Dict[str, Task]` - UUID4 keys → Task objects
- **Behavior**:
  - `add()`: Store `task.id → task` in dictionary
  - `get()`: Return `storage[task_id]` or None
  - `get_all()`: Return `sorted(storage.values(), key=lambda t: t.created_at, reverse=True)`
  - `update()`: Replace `storage[task.id]` with updated task
  - `delete()`: `del storage[task_id]`
  - `exists()`: `task_id in storage`

**Dependencies**: Domain layer (`Task` entity), `typing` (for type hints)

---

### CLI Layer (`Phase-1/src/cli/`)

**Responsibility**: User interface, input/output, orchestration of CRUD operations.

#### Main Menu (`Phase-1/src/cli/menu.py`)
- **Spec Reference**: CLI Interaction Specification (spec.md lines 257-273)
- **Menu Structure**:
  ```
  =================================
      TODO APP - MAIN MENU
  =================================
  1. Create Task
  2. View All Tasks
  3. Update Task
  4. Mark Task as Complete
  5. Delete Task
  6. Exit
  =================================
  Select an option (1-6): _
  ```
- **Function**: `display_menu(repository: RepositoryInterface) -> None`
  - Loop until user selects "6. Exit"
  - Capture `input()` for menu choice
  - Call corresponding operation handler
  - Handle invalid menu options with re-prompt

#### CRUD Operations (`Phase-1/src/cli/operations.py`)
- **Spec Reference**: User Stories P1-P5 (spec.md lines 22-115)
- **5 Operation Functions**:
  1. `create_task_operation()` - P1: Create task with title/description validation
  2. `view_all_tasks_operation()` - P2: Display task list with [✓]/[ ] indicators
  3. `view_task_details_operation()` - P2: Display full task details
  4. `update_task_operation()` - P3: Update title/description with Enter to skip
  5. `mark_complete_operation()` - P4: Transition pending → complete
  6. `delete_task_operation()` - P5: Delete task with y/n confirmation

**Dependencies**: Domain layer (`Task`, exceptions), Storage layer (`RepositoryInterface`)

---

### Application Entry Point (`Phase-1/src/main.py`)

**Responsibility**: Application initialization, dependency injection, execution start.

**Flow**:
1. Configure structured logging (JSON format, level from environment or default INFO)
2. Instantiate `MemoryRepository()`
3. Call `display_menu(repository)`
4. Handle global exceptions (log critical errors, display user-friendly message)

**Logging Configuration**:
- **Format**: JSON with timestamp, level, service="todo-cli", message, context
- **Levels**: DEBUG (dev), INFO (operations), WARNING (issues), ERROR (failures)

**Dependencies**: CLI layer (`menu`), Storage layer (`MemoryRepository`), `logging`

---

## Interfaces & Internal Contracts

### Domain → Storage Contract

**RepositoryInterface** defines the contract between Domain and Storage:

```python
from abc import ABC, abstractmethod
from typing import Optional, List
from src.domain.task import Task

class RepositoryInterface(ABC):
    @abstractmethod
    def add(self, task: Task) -> None:
        """Store task. Raises ValueError if task.id already exists."""
        pass

    @abstractmethod
    def get(self, task_id: str) -> Optional[Task]:
        """Retrieve task by ID. Returns None if not found."""
        pass

    @abstractmethod
    def get_all(self) -> List[Task]:
        """Retrieve all tasks sorted by created_at DESC."""
        pass

    @abstractmethod
    def update(self, task: Task) -> None:
        """Update existing task. Raises TaskNotFoundError if not found."""
        pass

    @abstractmethod
    def delete(self, task_id: str) -> None:
        """Remove task. Raises TaskNotFoundError if not found."""
        pass

    @abstractmethod
    def exists(self, task_id: str) -> bool:
        """Check if task exists."""
        pass
```

### CLI → Domain/Storage Contract

**CLI operations depend on**:
- `Task` entity methods: `update_title()`, `update_description()`, `mark_complete()`, `to_dict()`
- `RepositoryInterface` methods: `add()`, `get()`, `get_all()`, `update()`, `delete()`
- Domain exceptions: `DomainValidationError`, `DomainStateError`, `TaskNotFoundError`

**Error Propagation**:
- Domain raises exceptions → CLI catches and displays user-friendly messages
- CLI never exposes stack traces to users (NFR-012, spec.md line 389)

---

## Architectural Decision References

| Decision | Specification Reference | Rationale |
|----------|------------------------|-----------|
| **Three-layer architecture** | Constitution Principle IV, NFR-015 to NFR-017 | Clean separation enables independent testing, parallel development, future technology swaps |
| **UUID4 for Task IDs** | Domain Model Invariant 6, Key Entities | Globally unique, future-proof for distributed systems (Phase II+) |
| **Enum for status constraint** | Domain Model Invariant 4 | Type safety, prevents invalid status values |
| **Auto-truncate descriptions** | Domain Model Invariant 3, Acceptance Scenario P1.4 | User-friendly (no hard rejection), logs warning for observability |
| **Menu-driven CLI** | CLI Interaction Specification | Simplifies UX for console app, no command-line argument parsing needed |
| **Dictionary storage** | Phase I constraints, Out of Scope | Simplest in-memory solution, meets Phase I requirements, easy to swap for database in Phase II |
| **Exception-based error handling** | Domain Exceptions, NFR-012 to NFR-014 | Clear error semantics, user-friendly messages, no crashes on user errors |
| **Dependency inversion** | NFR-015 to NFR-017, Constitution Principle IV | CLI/Storage depend on Domain abstractions, enables testing with mocks |
| **ISO 8601 timestamps** | Key Entities, Formatting Standards | Standard format, future timezone support (Phase II+) |
| **Structured JSON logging** | NFR-009 to NFR-011, Constitution Principle VI | Machine-readable, supports future observability stack (Phase IV+) |

---

## Significant Architectural Decisions (ADR Candidates)

The following decisions meet the three-part ADR test (Impact + Alternatives + Scope):

### ADR 001: In-Memory Dictionary Storage vs. File-Based Persistence
- **Impact**: Long-term (affects Phase II migration path)
- **Alternatives**: Dictionary, JSON file, SQLite, pickle
- **Scope**: Cross-cutting (affects persistence layer and testing strategy)
- **Decision**: Dictionary-based for Phase I
- **Rationale**: Phase I explicitly excludes file/database persistence (Out of Scope, spec.md line 405). Dictionary is simplest, meets all requirements, minimal code. Phase II will introduce Neon DB PostgreSQL with migration strategy.
- **Recommendation**: Document via `/sp.adr "In-Memory Dictionary Storage for Phase I"`

### ADR 002: Exception-Based Error Handling vs. Result Types
- **Impact**: Long-term (affects all error handling across layers)
- **Alternatives**: Exceptions, Result[T, E] types, error codes
- **Scope**: Cross-cutting (domain, CLI, storage layers)
- **Decision**: Exception-based error propagation
- **Rationale**: Python idiomatic, clear error semantics, specification defines 3 exception types. Result types add complexity without benefit in Python ecosystem.
- **Recommendation**: Document via `/sp.adr "Exception-Based Error Handling Strategy"`

### ADR 003: UUID4 vs. Auto-Increment IDs
- **Impact**: Long-term (affects Phase II database schema)
- **Alternatives**: UUID4, auto-increment integers, NanoID, ULID
- **Scope**: Cross-cutting (affects domain model, storage, API design in Phase II)
- **Decision**: UUID4 for globally unique IDs
- **Rationale**: User-approved during specification creation. Globally unique (no collisions), future-proof for distributed systems, enables offline task creation (Phase III AI agents).
- **Recommendation**: Document via `/sp.adr "UUID4 for Task Identifiers"`

---

## Non-Functional Requirements Implementation

### Performance (NFR-001 to NFR-003)
- Operations complete within 100ms for lists < 1000 tasks
- Handle up to 10,000 tasks without exceeding 100MB RAM
- Application starts within 1 second

**Implementation**:
- Dictionary lookups O(1) for `get()`, `delete()`, `exists()`
- `get_all()` sorts entire list O(n log n), acceptable for < 1000 tasks
- Performance benchmark tests in integration test suite

### Code Quality (NFR-004 to NFR-008)
- 80% minimum test coverage (pytest-cov)
- Type hints throughout (mypy validation)
- Zero ruff linting errors
- Black formatting (100 char line length)
- Google-style docstrings for all public methods

**Implementation**:
- Type hints on all function signatures
- Docstrings with Args, Returns, Raises sections
- Pre-commit hooks for ruff, black, mypy (defined in pyproject.toml)

### Logging (NFR-009 to NFR-011)
- Structured JSON logging
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Truncate descriptions in logs to 50 chars (privacy)

**Implementation**:
- Python `logging` with JSON formatter
- Log domain validation failures at WARNING level
- Log task operations (create, update, delete) at INFO level

### Error Handling (NFR-012 to NFR-014)
- User-friendly error messages (no stack traces)
- Application never crashes on user errors
- Exception hierarchy: DomainValidationError, DomainStateError, TaskNotFoundError

**Implementation**:
- CLI catches all domain exceptions, displays messages prefixed with `✗`
- Global exception handler in `main.py` catches unexpected errors, logs with stack trace, displays generic "An error occurred" message

---

## Testing Strategy

### Test Distribution (Target: 60-70 tests)
- Unit Tests (Domain Layer): 35-40 tests
- Integration Tests (CLI + Storage): 25-30 tests

### Unit Tests (Domain Layer)

**`tests/unit/domain/test_task_entity.py` (12 tests)**
- Task creation with valid/invalid inputs
- Title validation (whitespace trimming, length enforcement)
- Description auto-truncation at 2000 chars
- UUID4 generation and uniqueness
- Status default to "pending"
- Timestamp immutability (created_at)

**`tests/unit/domain/test_task_lifecycle.py` (15 tests)**
- `update_title()` with valid/invalid title
- `update_description()` with valid description and truncation
- `mark_complete()` on pending/complete tasks
- `updated_at` timestamp updates
- `completed_at` immutability

**`tests/unit/domain/test_task_validation.py` (10 tests)**
- Unicode characters in title (café ☕)
- Special characters in description (#123 (urgent!))
- Emoji in title/description
- Newlines in description (preserved)
- Edge cases (exactly 200 chars, 201 chars, whitespace-only title)

### Integration Tests (CLI + Storage)

**`tests/integration/test_create_workflow.py` (6 tests)** - User Story P1
**`tests/integration/test_view_workflow.py` (6 tests)** - User Story P2
**`tests/integration/test_update_workflow.py` (8 tests)** - User Story P3
**`tests/integration/test_complete_workflow.py` (5 tests)** - User Story P4
**`tests/integration/test_delete_workflow.py` (5 tests)** - User Story P5

### TDD Workflow (Red-Green-Refactor)
1. **Red**: Write failing test defining desired behavior
2. **Green**: Implement minimal code to make test pass
3. **Refactor**: Improve code quality while keeping tests green

**Enforcement**: Test Strategy Architect agent blocks implementation if tests not written first

---

## Migration & Rollback Strategy

### Phase I → Phase II Migration Path
- **Current**: Dictionary-based in-memory storage
- **Future**: Neon DB PostgreSQL with Alembic migrations
- **Strategy**:
  1. `RepositoryInterface` remains unchanged (contract preserved)
  2. Create `PostgresRepository` implementing `RepositoryInterface`
  3. Swap `MemoryRepository` → `PostgresRepository` in `main.py`
  4. Data migration: Manual export/import (acceptable for hackathon, no production data)

### Code Rollback Strategy
- **Version Control**: Git commits with feature branch workflow
- **Rollback**: `git revert` or `git checkout` previous commit
- **No Data Loss**: Phase I has no persistent data (in-memory only)

---

## Python Configuration

### pyproject.toml (`Phase-1/pyproject.toml`)

```toml
[project]
name = "todo-app"
version = "0.1.0"
description = "Phase I - In-Memory Python Console Todo Application"
requires-python = ">=3.13"
dependencies = []

[project.optional-dependencies]
dev = [
    "pytest>=8.0",
    "pytest-cov>=4.1",
    "ruff>=0.1",
    "black>=24.0",
    "mypy>=1.8",
]

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "--cov=src --cov-report=term --cov-report=html"
python_files = "test_*.py"
python_functions = "test_*"

[tool.coverage.run]
source = ["src"]
omit = ["tests/*"]

[tool.coverage.report]
fail_under = 80.0
show_missing = true

[tool.ruff]
line-length = 100
target-version = "py313"
select = ["E", "F", "W", "I", "N", "UP"]

[tool.black]
line-length = 100
target-version = ["py313"]

[tool.mypy]
python_version = "3.13"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
```

---

## Implementation Execution Plan

### Prerequisites
- Python 3.13+ installed
- UV package manager installed (`pip install uv`)
- Git initialized on branch `001-task-crud-operations`

### Execution Sequence
1. **sp.tasks** - Generate dependency-ordered task breakdown (tasks.md)
2. **sp.implement** - Execute tasks following TDD workflow (Red-Green-Refactor)
3. **Validation** (all commands run from `Phase-1/` directory):
   - `pytest tests/ --cov=src --cov-report=term` (80% coverage required)
   - `ruff check src/` (zero errors required)
   - `black src/` (formatting validation)
   - `mypy src/` (type checking validation)
4. **sp.git.commit_pr** - Commit changes and create pull request

### Acceptance Criteria (Ready for Phase II)
- [x] All 5 CRUD operations functional
- [x] 80% unit test coverage achieved (pytest-cov)
- [x] 70% integration test coverage achieved
- [x] All tests passing (60-70 tests green)
- [x] Zero ruff linting errors
- [x] Zero mypy type errors
- [x] Black formatting applied
- [x] Application runs without crashes on user input
- [x] Structured JSON logging implemented
- [x] User-friendly error messages (no stack traces)
- [x] README.md with setup instructions
- [x] .env.example with configuration template

---

## Risk Analysis

### Technical Risks
| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Test coverage < 80% | Low | High | Test Strategy Architect blocks merge if coverage insufficient |
| Unicode handling issues | Medium | Low | Explicit tests for Unicode (café ☕), emoji. Python 3.13 handles Unicode natively |
| Dictionary memory overflow (10K tasks) | Low | Medium | Performance benchmark test validates < 100MB for 10K tasks |
| Timestamp timezone issues | Medium | Low | Use `datetime.now()` for Phase I (local time). Phase II will use UTC with timezone support |

### Process Risks
| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| TDD not followed | Low | High | Test Strategy Architect blocks implementation if tests not written first |
| Specification drift | Low | High | Spec Governance Enforcer validates all changes reference approved spec |
| Code quality violations | Low | Medium | Pre-commit hooks for ruff, black, mypy. CI validation before merge |

---

## Conclusion

This architectural plan provides a complete blueprint for implementing Phase I Task CRUD Operations following Constitutional principles and specification requirements. The three-layer architecture (Domain/CLI/Storage) with dependency inversion ensures clean separation, testability, and future extensibility.

**Key Success Factors**:
1. TDD strictly enforced (tests written first, 80% coverage minimum)
2. Domain invariants implemented correctly (10 NON-NEGOTIABLE rules)
3. Clean layer separation (no circular dependencies)
4. User-friendly CLI with proper error handling
5. Structured logging for observability

**Next Steps**:
1. Generate `data-model.md` (Phase 1 of /sp.plan)
2. Generate `contracts/task-entity-contract.md` (Phase 1 of /sp.plan)
3. Generate `quickstart.md` (Phase 1 of /sp.plan)
4. Run `/sp.adr` for the 3 significant architectural decisions
5. Run `/sp.tasks` to generate task breakdown
6. Execute `/sp.implement` following TDD workflow

**Constitutional Compliance**:
- ✅ Principle I (SDD): Specification approved, plan references spec throughout
- ✅ Principle III (TDD): Red-Green-Refactor workflow defined, Test Strategy Architect enforces
- ✅ Principle IV (Separation): Domain/CLI/Storage layers clearly separated
- ✅ Principle VI (Observability): Structured JSON logging defined

---

**Plan Status**: Approved and persisted. Ready for Phase 1 design artifacts and ADR documentation.
